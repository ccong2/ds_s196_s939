{
  "hash": "354b2316d46c232aa57116c489a33bd9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Describe neighborhood dynamics with ![](../img/Rlogo.png){width=60px}\"\nsubtitle: <span style=\"color:#2C3E50\">11.S196/11.S939 Applied Data Science for Cities</span>\ndate: \"Last Updated 2024-11-06\"\nformat: html\neditor: visual\nexecute: \n  warning: false\n---\n\n\n# Overview\n\nIn this lab, we will develop a place profile to quantify the physical and environmental characteristics of a given area. Planners are usually interested in understanding and enhance improving urban environments. Our approach will involve utilizing spatial data and conducting spatial analysis.\n\n![](../img/lab3_quantify_place.gif)\n\nTo put things into context, we will describe **pedestrian-friendly built environment** in Boston neighborhoods. Urban factors such as the presence of walking facilities, the density and variety of businesses, the number of residents and jobs, and streetscape elements like benches, storefronts, and shade all influence the extent and nature of walkable areas ([Lai & Kontokosta, 2018](https://www.sciencedirect.com/science/article/pii/S0169204618308491); [Frank et al., 2006](10.1080/01944360608976725); [Owen et al., 2007](10.1016/j.amepre.2007.07.025); [Ewing & Cervero, 2010](https://doi.org/10.1080/01944361003766766)).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(tidyverse)\nlibrary(osmdata)\nlibrary(DT)\nlibrary(scales)\n```\n:::\n\n\nFor the purpose of demonstrating how to gather, combine and analyze spatial data from different sources, we are going to develop three relatively simple indicators to measure the pedestrian environment in a Boston neighborhoods: **sidewalk density**, **number of** **restaurants measured by points of interest (POI), and tree canopy coverage**.\n\n# Boston Neighborhoods\n\nFrom [Analyze Boston](https://data.boston.gov/), let's navigate to the [Boston neighborhood boundaries](https://data.boston.gov/dataset/census-2020-block-group-neighborhoods) page. Find the **shapefile** format, click Explore, and Go to resource. Save the zipped file to your project folder and then Unzip it. They are the polygons showing the boundaries of neighborhoods in Boston.\n\n> Note: If you are interested, here is how we can directly unzip a file with R commands.\n>\n> \n> ```{.default}\n> unzip(zipfile = \"your_file_name.zip\", exdir = \"data\", overwrite = TRUE)   \n> file.remove(\"your_file_name.zip\")}\n> ```\n\nUse `st_read()` in the `sf` package to read in the data. You may want to apply the correct path on your end.\n\n\n\n```{.default}\nneighborhood <- st_read(\"Boston_Neighborhood_Boundaries_approximated_by_2020_Census_Block_Groups.shp\")\n```\n\n::: {.cell}\n\n:::\n\n\nThere are many columns in this dataset, but we will choose the ones we need (neighborhood names and population) and assign them identifiable names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nneighborhood <- neighborhood |>       \n  select(nbh_name = blockgr202, population = tot_pop_al)\n```\n:::\n\n\nNote that **this does not remove the `geometry`**—geometries are \"sticky,\" meaning this column will stay attached to your table unless you explicitly remove them using `st_drop_geometry()`.\n\n# Strategize our task\n\nEventually we aim to have a table where each row represents a neighborhood, and each column provides the values of a specific indicator, such as:\n\n| Neighborhood | Sidewalk Density | Tree Canopy Coverage | Number of Restaurants |\n|------------------|------------------|------------------|------------------|\n| Allston      | xx               | xx                   | xx                    |\n| Back Bay     | xx               | xx                   | xx                    |\n\n-   We have [line data for sidewalks](https://data.boston.gov/dataset/sidewalk-centerline). But we can split sidewalks at neighborhood boundaries (`st_intersection`), and calculate the total sidewalk length within each neighborhood.\n\n-   Using [tree canopy polygon data](https://data.boston.gov/dataset/treekeeper-street-trees). Similarly, we can identify the overlap (`st_intersection`) between tree canopy and neighborhoods and sum the canopy area within each neighborhood.\n\n-   We’ll obtain restaurant location data from OpenStreetMap. These are point data, so we’ll count the number of restaurant points within each neighborhood.\n\n-   Then these three tables will be joined together to create the table we want.\n\n# Sidewalk density\n\nFrom the front page of Analyze Boston, search for \"sidewalk\", you will find the [Sidewalk Centerline](https://data.boston.gov/dataset/sidewalk-centerline) data. Download the **Shapefile** to your data folder, unzip it, and then use `st_read()` to read it into R and assign it to a variable (named e.g. \"sidewalk\").\n\n\n::: {.cell}\n\n:::\n\n\nCheck the results by clicking `sidewalk` in the Environment panel, or equivalently, using `View(sidewalk)`. Details of each line are stored in the `geometry` attribute. While these details aren't meant for humans to read directly, machines can interpret it and perform operations, such as calculating areas for polygons and length for lines:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsidewalk |> mutate(length = st_length(geometry))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 110031 features and 4 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 742172.1 ymin: 2909272 xmax: 811805.7 ymax: 2969957\nProjected CRS: NAD83 / Massachusetts Mainland (ftUS)\nFirst 10 features:\n   OBJECTID     TYPE ShapeSTLen                       geometry\n1         1 CWALK-CL  64.029105 LINESTRING (755403.2 295473...\n2         2 CWALK-CL  48.941826 LINESTRING (757458.1 295887...\n3         3 CWALK-CL  27.003284 LINESTRING (754873.1 295631...\n4         4 CWALK-CL  50.113763 LINESTRING (756019.7 295713...\n5         5 CWALK-CL  33.144903 LINESTRING (755399.5 295530...\n6         6 CWALK-CL  51.157055 LINESTRING (756373.4 295663...\n7         7 CWALK-CL  59.903693 LINESTRING (756988.7 295606...\n8         8 CWALK-CL  77.648147 LINESTRING (756633.2 295547...\n9         9 CWALK-CL   5.862916 LINESTRING (758622.5 295417...\n10       10 CWALK-CL  44.308273 LINESTRING (760087.9 295349...\n                       length\n1  64.029105 [US_survey_foot]\n2  48.941826 [US_survey_foot]\n3  27.003284 [US_survey_foot]\n4  50.113763 [US_survey_foot]\n5  33.144903 [US_survey_foot]\n6  51.157055 [US_survey_foot]\n7  59.903693 [US_survey_foot]\n8  77.648147 [US_survey_foot]\n9   5.862916 [US_survey_foot]\n10 44.308273 [US_survey_foot]\n```\n\n\n:::\n:::\n\n\nWe have an additional column, `length` , that stores the length of each segment. These lengths are calculated in feet because the neighborhood shapefile uses EPSG code 2249, which represents the \"State Plane coordinate system Massachusetts Mainland (ftUS)\" projection. State Plane projections are \"projected\", meaning that x and y coordinates are measured in linear units (feet, in our case).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(sidewalk)$epsg  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2249\n```\n\n\n:::\n\n```{.r .cell-code}\nst_crs(sidewalk)$input\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NAD83 / Massachusetts Mainland (ftUS)\"\n```\n\n\n:::\n:::\n\n\nSecond, the values are \"unit\" objects. Although we can do basic math operations on unit objects, we typically convert them to simple numeric values using `as.numeric()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsidewalk |> mutate(length = as.numeric(st_length(geometry)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 110031 features and 4 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 742172.1 ymin: 2909272 xmax: 811805.7 ymax: 2969957\nProjected CRS: NAD83 / Massachusetts Mainland (ftUS)\nFirst 10 features:\n   OBJECTID     TYPE ShapeSTLen                       geometry    length\n1         1 CWALK-CL  64.029105 LINESTRING (755403.2 295473... 64.029105\n2         2 CWALK-CL  48.941826 LINESTRING (757458.1 295887... 48.941826\n3         3 CWALK-CL  27.003284 LINESTRING (754873.1 295631... 27.003284\n4         4 CWALK-CL  50.113763 LINESTRING (756019.7 295713... 50.113763\n5         5 CWALK-CL  33.144903 LINESTRING (755399.5 295530... 33.144903\n6         6 CWALK-CL  51.157055 LINESTRING (756373.4 295663... 51.157055\n7         7 CWALK-CL  59.903693 LINESTRING (756988.7 295606... 59.903693\n8         8 CWALK-CL  77.648147 LINESTRING (756633.2 295547... 77.648147\n9         9 CWALK-CL   5.862916 LINESTRING (758622.5 295417...  5.862916\n10       10 CWALK-CL  44.308273 LINESTRING (760087.9 295349... 44.308273\n```\n\n\n:::\n:::\n\n\nNow we are going to perform intersection. `st_intersection()` finds the shared part of two spatial objects. If we overlay `sidewalks` with the entire `neighborhoods`, it splits sidewalks at neighborhood boundaries. Each split segment is linked to the attributes of the neighborhood it falls within.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsidewalk_data <- \n  st_intersection(sidewalk, neighborhood)\n```\n:::\n\n\nIt takes a few seconds to run, but when it's finished, you will see that neighborhood names are attached in `sidewalk_data`! Then we can calculate the length of each split sidewalk segment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsidewalk_data <- sidewalk_data |> \n  mutate(length = as.numeric(st_length(geometry))) \n```\n:::\n\n\nWith neighborhood names here in the table, we will `group_by()` neighborhood and `summarise()` the total sidewalk length.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsidewalk_data <- sidewalk_data |> \n  group_by(nbh_name) |> \n  summarise(sidewalk_length = sum(length)) |> \n  st_drop_geometry()\n```\n:::\n\n\nI've dropped the geometry so we have a plain table. When it's finished, you can `View(sidewalk_data)` . It has 24 rows, showing the total sidewalk length in feet in each neighborhood.\n\n# Tree canopy\n\nFor street trees, we will use the tree canopy data available for Boston. We have a visualization from the [Treekeeper Street Trees](https://bostonma.treekeepersoftware.com/index.cfm?deviceWidth=2082). To work with this data, download and read the shapefile from [this link](https://data.boston.gov/dataset/treekeeper-street-trees).\n\nAs usual, check the CRS. This data uses EPSG: 4326, which is an unprojected system where locations are stored in longitude and latitude. To calculate areas, we need to use `st_transform` to convert it to the same projection as the sidewalks, EPSG: 2249.\n\n\n\n```{.default}\ntree <- st_read(\"Treekeeper_Street_Trees.shp\") |> \n  st_transform(2249)\n```\n\n::: {.cell}\n\n:::\n\n\nView the attributes of the dataset. It uses **point** geometry, which indicates the location of trees. However, the dataset includes a `dbh` attribute, representing the diameter of trees at breast height. We can use this attribute to create a buffer around each tree to represent the canopy area.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntree_buffer <- st_buffer(tree, dist = tree$dbh/2)\n```\n:::\n\n\nTree canopies may overlap, so we need to \"dissolve\" these buffers into a single large polygon. The `st_union()` function achieves this by merging the overlapping areas to create the entire covered region.\n\n> Note: In the following code, the two steps following `st_union()` may not always be necessary. In this specific case, I used `st_cast()` to convert multiple polygons into a single one. You won't need them if geometries being unioned are simple.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntree_data <- st_union(tree_buffer) |> \n  # Cast the unioned geometry to POLYGON type\n  st_cast(\"POLYGON\") |> \n  # Convert the result back to an sf object and rename the geometry column\n  st_as_sf() |> rename(geometry = x)\n```\n:::\n\n\n![](../img/lab3_dissolve.png)\n\nThen we can calculate the area of tree canopy in each neighborhood.\n\nSimilar to the sidewalk data, intersect tree canopy and neighborhood polygons, then use mutate to calculate the overlapping areas, and then summarize the total areas by neighborhood. In the following code, we chained these steps together into one sentence.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntree_data <- \n  st_intersection(tree_data, neighborhood) |> \n  mutate(area = as.numeric(st_area(geometry))) |> \n  group_by(nbh_name) |> \n  summarize(canopy_area = sum(area)) |> \n  st_drop_geometry()\n```\n:::\n\n\nAgain, it take a few seconds to run. When it's finished, you will have a `tree_data` object that has 23 rows - why one less than the sidewalk data - we will find out soon. But now we can pause and take a moment to appreciate what we’ve accomplished. We’ve worked with large spatial datasets using just a few lines of code. Consider the numerous clicks required in GIS; programming allows us to scale and automate many complex processes.\n\nTo free up memory, we can now delete a few intermediate objects in the R environment that are no longer needed:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(sidewalk, tree, tree_buffer)\n```\n:::\n\n\n# Obtain and process OSM data\n\nTo measure the number of amenities, we are going to download points of interest (POI) from OpenStreetMap (OSM). By allowing anyone to contribute, OSM enables the real-time evolution of its database and offers convenient options for downloading data through its free [Overpass API](https://overpass-turbo.eu/#). In this lab, we will use the [`osmdata` R package](https://cran.r-project.org/web/packages/osmdata/vignettes/osmdata.html), which simplifies API download queries without much understanding of the overpass syntax.\n\nIn order to obtain data from OSM, you will need to specify:\n\n-   a bounding box\n-   key-value pairs\n\n### The bounding box\n\nA bounding box is like a window of where you want to clip a piece of map. It can be defined by manually specifying two longitude (x) - latitude (y) pairs. The following example defines one bounding box for Boston, the first pair (-71.188, 42.238) is the lower-left corner (southwest), and the second pair (-70.924, 42.393) is the upper-right corner (northeast)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A bounding box for Boston\nbbox = c(-71.188, 42.238, -70.924, 42.393)\n```\n:::\n\n\n### The key-value pairs\n\nAn overpass query `opq` starts with engaging with the bounding box like this:\n\n`q <- opq(bbox)`\n\nFollowing the initial `opq(bbox)` call, we will build queries by adding one or more features (`add_osm_feature()`). Features are defined by *key-value pairs*. For example, restaurants are categorized in OSM under `key=amenity`, and `value=restaurant`. Here is [a complete list of key-value pairs on OSM](https://wiki.openstreetmap.org/wiki/Map_Features).\n\nA query of all restaurants within the bounding box of Boston will be constructed as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrestaurants <- opq(bbox)|>   \n  add_osm_feature(key = \"amenity\", value = \"restaurant\") |>  \n  osmdata_sf() \n```\n:::\n\n\nThe retrieved object `restaurants` is a large list of `sf` objects with many attributes; What we need is one named `osm_points` nested in this list. The following code extracts `osm_ponits`, and selects only the `name` attribute and the associated geometry.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrestaurants <- restaurants$osm_points |> select(name)\n```\n:::\n\n\nNow we can `View` the `restaurants` object. If you notice many missing values (NAs) in the names, scroll down to find more typical entries of restaurant names. This is a common issue with crowdsourced data like OSM, where the information provided may be incomplete.\n\n> Note: if you want to visually check your result, use `mapview(restaurants, legend = FALSE)`\n\nCheck the CRS of `restaurant`. We want to associate our downloaded OSM data with the `neighborhood` shapefile, so they need to have the same CRS. Here we are converting it using `st_transform()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrestaurants <- restaurants |> \n  st_transform(2249)\n```\n:::\n\n\nThat's it. Below I am repeating the \"download, extract, and transform\" process. You can try it with any other OSM data, such as grocery stores, fast food places, and other amenities, by applying the corresponding key-value pairs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# bbox = c(-71.188, 42.238, -70.924, 42.393)\n# restaurants <- \n#   opq(bbox)|>   \n#   add_osm_feature(key = \"amenity\", value = \"restaurant\") |>  \n#   osmdata_sf() |> \n#   pluck(\"osm_points\") |> \n#   select(name)|> \n#   st_transform(2249)\n```\n:::\n\n\n## Calculate the number of POIs by neighborhood\n\nWe now have a point shapefile (`restaurants`) and a polygon shapefile (`neighborhood`), and we want to count the number of points in each neighborhood. They are points, so we don't need to look for overlapping/intersecting parts, `st_join()` will be sufficient.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrestaurant_data <- \n  st_join(restaurants, neighborhood) \n```\n:::\n\n\nTake a look at what we've got. It's still the same set of restaurants but each one has neighborhood information joined to it. Remove those fall outside of our neighborhood boundary, then count by neighborhood:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrestaurant_data <- \n  restaurant_data |> \n  filter(!is.na(nbh_name)) |> \n  count(nbh_name, name = \"restaurant\") |> \n  st_drop_geometry()\n```\n:::\n\n\n# Assemble results\n\nAfter calculating the three elements separately, we now have the following data for each neighborhood:\n\n-   `sidewalk_data`: Total sidewalk length in feet.\n-   `restaurant_data`: Number of POIs for restaurants.\n-   `tree_data`: Total area of street tree canopy in square feet.\n\nTo create comparable metrics, we'll normalize the raw data by calculating:\n\n-   **Sidewalk density:** total sidewalk length divided by neighborhood area (ft/sq.ft)\n-   **POI per capita:** total restaurant POIs divided by neighborhood population\n-   **Street tree coverage:** total tree canopy area divided by neighborhood area (sq.ft/sq.ft)\n\nOkay, do we have the population and area of the neighborhoods? Check out the `neighborhood` shapefile we have, yes, population is there, and we just need to calculate the area.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nneighborhood <- neighborhood |> \n  mutate(area = as.numeric(st_area(geometry))) \n```\n:::\n\n\nUp to this step we have four plain tables: `neighborhood`, `sidewalk_data`, `tree_data`, and `restaurant_data`, all sharing the key column `nbh_name`.\n\n`left_join()` merges two datasets by **keeping all rows from the left** and adding matching rows from the right based on a specified key column(s). It requires the arguments `x` (the left data), `y` (the right data), and `by` (the column(s) to join on).\n\nKeeping `neighborhood` on the left, we can join the other three tables one by one:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- \n  neighborhood |> \n  left_join(sidewalk_data, by = \"nbh_name\") |> \n  left_join(restaurant_data, by = \"nbh_name\") |> \n  left_join(tree_data, by = \"nbh_name\")\n```\n:::\n\n\nLet's `View` the result.\n\nBy observing `result` you'll notice: the canopy coverage for Harbor Island is not recorded - which is why we had one less rows for tree data. The original TreeKeeper dataset does not cover islands. We will also find no population is recorded for Harbor Island as well. We can choose to exclude this area and focus only on the geography cropped to the coastline.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- result |> filter(nbh_name != \"Harbor Islands\")\n```\n:::\n\n\nLet's calculate the normalized metrics. Normalization can be done with a series of `mutate()` functions as shown below. Following that, we will `select()` only the final output columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- result |> \n  mutate(sidewalk_density = sidewalk_length/area,\n         restaurant_density = restaurant/population, \n         tree_coverage = canopy_area/area) |> \n  select(nbh_name, sidewalk_density:tree_coverage) \n```\n:::\n\n\nHere we've got our final, summary table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 23 features and 4 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 739715.8 ymin: 2908294 xmax: 795290.1 ymax: 2970217\nProjected CRS: NAD83 / Massachusetts Mainland (ftUS)\nFirst 10 features:\n      nbh_name sidewalk_density restaurant_density tree_coverage\n1      Allston      0.008564768       0.0044373013   0.002969197\n2     Back Bay      0.014395888       0.0037267715   0.009808325\n3  Beacon Hill      0.015852077       0.0019280206   0.009403056\n4     Brighton      0.009110513       0.0022346369   0.003135847\n5  Charlestown      0.007845821       0.0019351464   0.003728595\n6    Chinatown      0.013819173       0.0050398992   0.002365797\n7   Dorchester      0.008714112       0.0005155863   0.002624161\n8     Downtown      0.010884933       0.0092929894   0.001803340\n9  East Boston      0.003524056       0.0042028514   0.001524641\n10      Fenway      0.007478755       0.0021731641   0.002972764\n                         geometry\n1  MULTIPOLYGON (((758525.8 29...\n2  MULTIPOLYGON (((771539.2 29...\n3  MULTIPOLYGON (((774297.4 29...\n4  MULTIPOLYGON (((754177.9 29...\n5  MULTIPOLYGON (((773132.5 29...\n6  MULTIPOLYGON (((775639 2953...\n7  MULTIPOLYGON (((775867.2 29...\n8  MULTIPOLYGON (((773867.7 29...\n9  MULTIPOLYGON (((790148.5 29...\n10 MULTIPOLYGON (((756955.2 29...\n```\n\n\n:::\n:::\n\n\n# Present our result\n\nThere are plenty of ways to create nicer, more presentable tables than the default output. You can check out packages such as `DT` (for data tables):\n\n\n\n```{.default}\nresult |> \n  st_drop_geometry() |> \n  datatable()\n```\n\n\nThe calculated values may appear low and hard to distinguish. You can `rescale()` them to a range of 0-100 to create standardized \"scores\" for each neighborhood.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscores <- result |> \n  mutate(across(sidewalk_density:tree_coverage, \n                ~ rescale(., to = c(0, 100)) |> round(2)\n                ))\n\nscores |> \n  st_drop_geometry() |> \n  datatable()\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"datatables html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-df7f1f843816a8dd41eb\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-df7f1f843816a8dd41eb\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\",\"23\"],[\"Allston\",\"Back Bay\",\"Beacon Hill\",\"Brighton\",\"Charlestown\",\"Chinatown\",\"Dorchester\",\"Downtown\",\"East Boston\",\"Fenway\",\"Hyde Park\",\"Jamaica Plain\",\"Longwood\",\"Mattapan\",\"Mission Hill\",\"North End\",\"Roslindale\",\"Roxbury\",\"South Boston\",\"South Boston Waterfront\",\"South End\",\"West End\",\"West Roxbury\"],[40.89,88.19,100,45.32,35.06,83.51000000000001,42.1,59.71,0,32.08,16.19,32.36,66.95999999999999,32.42,78.61,54.49,39.15,54.52,41.59,4.14,93.42,47.79,21.83],[47.51,39.83,20.39,23.7,20.46,54.03,5.12,100,44.98,23.04,4.46,8.77,7.46,0,4.38,45.57,2.86,3.09,8.67,77.05,23.84,17.78,4.68],[18.24,62.19,59.58,19.31,23.12,14.36,16.02,10.74,8.949999999999999,18.26,10.05,12.74,14.92,20.08,12.51,15.98,20.79,21.23,23.41,0,100,9.58,28.85]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th> <\\/th>\\n      <th>nbh_name<\\/th>\\n      <th>sidewalk_density<\\/th>\\n      <th>restaurant_density<\\/th>\\n      <th>tree_coverage<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"columnDefs\":[{\"className\":\"dt-right\",\"targets\":[2,3,4]},{\"orderable\":false,\"targets\":0},{\"name\":\" \",\"targets\":0},{\"name\":\"nbh_name\",\"targets\":1},{\"name\":\"sidewalk_density\",\"targets\":2},{\"name\":\"restaurant_density\",\"targets\":3},{\"name\":\"tree_coverage\",\"targets\":4}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n------------------------------------------------------------------------\n\nAs our result is a spatial object, we can also create maps to show the scores in neighborhoods:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscores |> \n  pivot_longer(cols = sidewalk_density:tree_coverage,\n               names_to = \"indicators\", values_to = \"score\") |> \n  ggplot()+\n  geom_sf(aes(fill = score))+\n  facet_wrap(~ indicators)+\n  scale_fill_viridis_c()+\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](lab3_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\n------------------------------------------------------------------------\n\nWe can also make some [radar charts](https://r-graph-gallery.com/143-spider-chart-with-saveral-individuals.html) to show these scores - many examples on the linked page to customize the chart.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_neighborhood <- \"Downtown\"\n\n# install.packages(\"fmsb\")\nlibrary(fmsb)\n\n# Filter, select columns, and add max/min rows in one step\nchart <- rbind(\n  c(100, 100, 100),  # Max values\n  c(0, 0, 0),        # Min values\n  scores |> \n    st_drop_geometry() |> \n    filter(nbh_name == my_neighborhood) |>\n    select(sidewalk_density:tree_coverage)\n)\n\n# Plot radar chart\nradarchart(chart, title = my_neighborhood)\n```\n\n::: {.cell-output-display}\n![](lab3_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\n# Exercise\n\nWhat other indicators can you use to describe the built environment in Boston neighborhoods? For example, their transit supply (e.g. the number of [bus stops](https://gis.data.mass.gov/datasets/massgis::mbta-bus-stops-3/explore?location=42.346124%2C-71.067200%2C10.03), [rail stops](https://www.mass.gov/info-details/massgis-data-mbta-rapid-transit), or [Bluebike stations](https://bluebikes.com/system-data)), business activities (e.g., [supermarkets, cafes](https://wiki.openstreetmap.org/wiki/Map_features)), land use ([open spaces](https://data.boston.gov/dataset/open-space) or vacant land), or available facilities (e.g., [benches, gardens](https://wiki.openstreetmap.org/wiki/Map_features)).\n\nIn this exercise, you’ll continue exploring Boston neighborhoods by doing a mini-research to replicate or even expand on our process. Start by choosing 2-3 indicators that interest you, think about how you might calculate them, and then use spatial tools to work through your calculations. When you're ready, present your results in your preferred way.\n\nYou can download the datasets you need from Boston data sources or OSM. Feel free to use any of the code provided earlier that you find helpful. But keep in mind the primary goal of this exercise is to practice spatial analysis in R. You should operationalize your metrics in a manageable way and choose indicators that work for you.\n\n# Work Product\n\nPlease start a new Quarto Document to document your work. Submit the Rendered HTML file when you finish. Make sure you have included `embed-resources: true` in your YAML header, this is to help preserve all your pictures in your HTML.\n\n![](/img/lab3-html.PNG)\n\nPlease **upload your report to Canvas** **by the end of day, Tuesday, Nov 12.**\n",
    "supporting": [
      "lab3_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../site_libs/htmlwidgets-1.6.2/htmlwidgets.js\"></script>\n<link href=\"../site_libs/datatables-css-0.0.0/datatables-crosstalk.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/datatables-binding-0.33/datatables.js\"></script>\n<script src=\"../site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"../site_libs/dt-core-1.13.6/css/jquery.dataTables.min.css\" rel=\"stylesheet\" />\n<link href=\"../site_libs/dt-core-1.13.6/css/jquery.dataTables.extra.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/dt-core-1.13.6/js/jquery.dataTables.min.js\"></script>\n<link href=\"../site_libs/crosstalk-1.2.0/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/crosstalk-1.2.0/js/crosstalk.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}